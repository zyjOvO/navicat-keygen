#include "PatchSolutions.hpp"
#include <assert.h>

const uint8_t PatchSolution1::Keyword[KeywordLength] = {
    0xfe, 0xfd, 0xfc, 0xf4, 0xfe, 0xd2, 0xf8, 0xf4, 0xf1, 0xd3, 0xde, 0xc7, 0xdf, 0xd3, 0xd0, 0xfd,
    0x8a, 0xc3, 0x85, 0xf4, 0xf6, 0xe9, 0xfc, 0xfc, 0xf2, 0xf5, 0xfa, 0xf5, 0xf6, 0xe9, 0x81, 0xfb,
    0xfe, 0xfd, 0xfc, 0xf4, 0xf4, 0xdf, 0xf2, 0xf9, 0xf2, 0xe5, 0xf0, 0xf7, 0xc0, 0x89, 0xdd, 0xcb,
    0xf5, 0x87, 0xe6, 0xdd, 0xf4, 0xd9, 0xf8, 0xfb, 0xde, 0xf9, 0xcf, 0xc5, 0x8f, 0x80, 0x80, 0xf3,
    0xc2, 0xd0, 0xe2, 0x8f, 0xfa, 0x8a, 0xdd, 0xf3, 0xd7, 0xdc, 0x86, 0xdc, 0xf0, 0x81, 0xc0, 0xea,
    0xd0, 0xd9, 0xf9, 0xd8, 0xda, 0xf2, 0xd0, 0xfd, 0xc3, 0xf6, 0xf3, 0x82, 0xf2, 0x81, 0xef, 0xf2,
    0xe0, 0xf9, 0xf2, 0xd3, 0x8f, 0xd7, 0xe9, 0xfb, 0xca, 0x86, 0xde, 0xfc, 0xf3, 0xd5, 0xdd, 0xf4,
    0xc7, 0x80, 0xf7, 0xd5, 0xf2, 0xc1, 0xde, 0xcc, 0xc0, 0xc7, 0xf0, 0xd0, 0xd0, 0xd1, 0xd7, 0xcc,
    0xd2, 0x81, 0xc1, 0x83, 0xdd, 0xd5, 0x8a, 0x8f, 0x81, 0xe1, 0xf4, 0xd9, 0xf3, 0xd7, 0xca, 0xef,
    0xf9, 0xdf, 0xe1, 0xee, 0xf0, 0xe9, 0xd1, 0xca, 0xf2, 0xe3, 0xf8, 0xf0, 0x83, 0xde, 0xfb, 0xd7,
    0xf1, 0xc4, 0xfa, 0x85, 0xf2, 0xdd, 0xdd, 0xfd, 0x85, 0x86, 0xc7, 0xf9, 0xc4, 0xc9, 0xf4, 0xf8,
    0xd4, 0xd9, 0xe6, 0xd2, 0xf6, 0xc1, 0xc1, 0xf9, 0xe0, 0xe4, 0xf7, 0xe4, 0xfd, 0xf1, 0xf6, 0xfc,
    0xe1, 0x84, 0xe4, 0xd1, 0xed, 0xfe, 0xdb, 0xe8, 0xdd, 0xe1, 0x85, 0xd0, 0xc5, 0xd2, 0x8a, 0x8e,
    0xd5, 0xdd, 0xe3, 0xdb, 0xd0, 0xe1, 0xd0, 0xf6, 0xc6, 0xee, 0xe6, 0xf7, 0xda, 0xf1, 0xdb, 0xc9,
    0x8b, 0xee, 0xcd, 0xdf, 0xff, 0xe8, 0xdd, 0xca, 0x82, 0xdb, 0xf1, 0x82, 0xc3, 0xed, 0xc9, 0xcc,
    0xc0, 0xf2, 0xd6, 0xdf, 0x83, 0xe9, 0xf3, 0xce, 0xea, 0xfa, 0xdf, 0xf8, 0xd9, 0xff, 0xec, 0x88,
    0xe4, 0xe4, 0xfd, 0x80, 0xc5, 0xce, 0xfa, 0xd2, 0xf4, 0xd8, 0x84, 0xff, 0xe5, 0xf3, 0xcb, 0xc2,
    0xfe, 0xc0, 0xc4, 0xfa, 0xde, 0xdd, 0xd5, 0xc9, 0xc5, 0xd5, 0xdf, 0xe3, 0xdd, 0xc1, 0xcb, 0xdd,
    0xfc, 0xf7, 0x83, 0xf8, 0xda, 0xc1, 0xd4, 0xe3, 0xfe, 0xc2, 0xef, 0xf8, 0xf2, 0xea, 0x8a, 0xd2,
    0xc7, 0xf2, 0xf0, 0xc2, 0xfb, 0x89, 0xdc, 0xeb, 0xd1, 0xf7, 0xcc, 0xe2, 0xd1, 0xfc, 0xd4, 0xce,
    0xea, 0xcd, 0xe4, 0x87, 0xe0, 0xcc, 0x8d, 0xf5, 0xc7, 0x85, 0x87, 0xda, 0xcf, 0xde, 0x89, 0xcd,
    0xe5, 0xfd, 0xe7, 0x83, 0xda, 0xdb, 0xfe, 0xf4, 0x84, 0xec, 0xf6, 0xee, 0xfd, 0xea, 0xf1, 0xf5,
    0xf5, 0xfc, 0xe6, 0xd0, 0x86, 0xdf, 0xc3, 0xe2, 0xe4, 0xd5, 0xd7, 0xe4, 0xe4, 0xce, 0xd4, 0xce,
    0x82, 0xda, 0xc7, 0xda, 0x80, 0xcb, 0xee, 0x8c, 0xd0, 0xde, 0xcd, 0xda, 0xdd, 0xcd, 0xcc, 0xeb,
    0xd2, 0xc3, 0xfc, 0xf2, 0xf6, 0xe9, 0xf8, 0xf8
};

PatchSolution1::PatchSolution1() noexcept :
    _$$_FileViewHandle(MapViewTraits::InvalidValue),
    _$$_PatchOffset(InvalidOffset) {}

void PatchSolution1::SetFile(const MapViewTraits::HandleType& FileViewHandle) noexcept {
    _$$_FileViewHandle = FileViewHandle;
    _$$_PatchOffset = InvalidOffset;
}

bool PatchSolution1::FindPatchOffset() noexcept {
    if (_$$_FileViewHandle == MapViewTraits::InvalidValue)
        return false;

    auto ViewPtr = _$$_FileViewHandle.ConstView<uint8_t>();
    size_t ViewSize = _$$_FileViewHandle.Size();

    if (ViewSize < KeywordLength)
        return false;

    _$$_PatchOffset = InvalidOffset;

    ViewSize -= KeywordLength;
    for (size_t i = 0; i < ViewSize; ++i) {
        if (ViewPtr[i] == Keyword[0] && memcmp(ViewPtr + i, Keyword, KeywordLength) == 0) {
            _$$_PatchOffset = i;
            break;
        }
    }

    if (_$$_PatchOffset != InvalidOffset) {
        printf("PatchSolution1 ...... Ready to apply.\n");
        printf("    Info: Keyword offset = +0x%08zx\n", _$$_PatchOffset);
        return true;
    } else {
        printf("PatchSolution1 ...... Omitted.\n");
        return false;
    }
}

bool PatchSolution1::CheckKey(RSACipher* pCipher) const {
    std::string PublicKeyPEM =
        pCipher->ExportKeyString<RSAKeyType::PublicKey, RSAKeyFormat::PEM>();

    PublicKeyPEM.erase(PublicKeyPEM.find("-----BEGIN PUBLIC KEY-----"), 26);
    PublicKeyPEM.erase(PublicKeyPEM.find("-----END PUBLIC KEY-----"), 24);
    {
        std::string::size_type pos = 0;
        while ((pos = PublicKeyPEM.find('\n', pos)) != std::string::npos) {
            PublicKeyPEM.erase(pos, 1);
        }
    }

    return PublicKeyPEM.length() == KeywordLength;
}

void PatchSolution1::MakePatch(RSACipher* pCipher) const {
    if (_$$_FileViewHandle == MapViewTraits::InvalidValue || _$$_PatchOffset == InvalidOffset)
        throw Exception(__FILE__, __LINE__,
                        "PatchSolution1::MakePatch is not ready.");

    auto ViewPtr = _$$_FileViewHandle.View<uint8_t>();
    std::string PublicKeyPEM =
        pCipher->ExportKeyString<RSAKeyType::PublicKey, RSAKeyFormat::PEM>();

    PublicKeyPEM.erase(PublicKeyPEM.find("-----BEGIN PUBLIC KEY-----"), 26);
    PublicKeyPEM.erase(PublicKeyPEM.find("-----END PUBLIC KEY-----"), 24);
    {
        std::string::size_type pos = 0;
        while ((pos = PublicKeyPEM.find('\n', pos)) != std::string::npos) {
            PublicKeyPEM.erase(pos, 1);
        }
    }

    assert(PublicKeyPEM.length() == KeywordLength);

    {
        uint8_t key = 8;
        for (size_t i = 0; i < PublicKeyPEM.length(); ++i) {
            if (key == 0)
                key = 8;
            PublicKeyPEM[i] ^= 0xbb - key;
            --key;
        }
    }

    puts("****************************");
    puts("*   Begin PatchSolution1   *");
    puts("****************************");
    printf("@+0x%08zx\n", _$$_PatchOffset);
    puts("Previous:");
    PrintMemory(ViewPtr + _$$_PatchOffset,
                ViewPtr + _$$_PatchOffset + KeywordLength,
                ViewPtr);

    memcpy(ViewPtr + _$$_PatchOffset,
           PublicKeyPEM.c_str(),
           KeywordLength);

    puts("After:");
    PrintMemory(ViewPtr + _$$_PatchOffset,
                ViewPtr + _$$_PatchOffset + KeywordLength,
                ViewPtr);
    puts("");
}

